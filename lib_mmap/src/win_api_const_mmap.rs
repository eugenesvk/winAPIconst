/*! Get a Windows API constant value from a memory-mapped file (not included)

See win_api_const_mmap.ahk for an example on how to use in AutoHotkey
*/

use std::ffi::CString;
use widestring::{U16Str,WideChar,u16cstr,
  U16CString,U16CStr,	//   0 U16/U32-CString wide version of the standard CString type
  Utf16Str   ,       	// no0 UTF-16 encoded, growable owned string
};

// 0 Return thefound key in the rkyv dump
use std::path  	::{Path,PathBuf};
const DB_NAMEF 	:&str    	= "winAPI_Const.rkyv_data_0";
// const DB_EXT	:&str    	= "_data_0";
const DB_NAME  	:&str    	= "winAPI_Const.rkyv";
const DB_PATH  	:[&str;2]	= ["./data","."];
pub fn db_find() -> Result<PathBuf,Box<dyn std::error::Error>> {
  for fd in DB_PATH {
    let db_path = Path::new(fd).join(DB_NAMEF);
    if db_path.is_file() {return Ok(Path::new(fd).join(DB_NAME))} // return db name without extension, mmap-sync bugs with it
  }
  Err("✗ No database!".into())
}

use std::{slice,ptr};
use mmap_sync::synchronizer::Synchronizer;
// use asm4ahk_lib::win32const_dump::Win32const; // exports all workspace functions, so use ↓ directly
#[derive(rkyv::Archive,rkyv::Deserialize,rkyv::Serialize,Debug,PartialEq)]
// #[archive(compare(PartialEq))] // This will generate a PartialEq impl between our unarchived and archived types
#[archive_attr(derive(Debug))] // We can pass attributes through to generated types with archive_attr
#[archive(check_bytes)]
pub struct Win32const { #[with(rkyv_wrappers::as_hashmap::AsHashMap)] pub hash_map_vec:Vec<(String,String)> }

fn ret_error(err_msg:&U16CStr, err_sz:u32,err_ptr:*mut WideChar) -> *const WideChar { // create a buffer from pointer/size and fill it in
  let err_msg_bufer   	= unsafe{slice::from_raw_parts_mut::<WideChar>(err_ptr, err_sz as usize)};
  let err_msg_b:&[u16]	= err_msg.as_slice_with_nul(); // converts to a slice of the underlying elements, including the nul terminator.
  let max_buff_len    	= std::cmp::min(err_msg_b.len(),err_sz as usize);
  err_msg_bufer[..max_buff_len].copy_from_slice(&err_msg_b[..max_buff_len]);
  ptr::null()
}

#[no_mangle] pub extern "C"
fn get_win32_const(pre:&WideChar,s:&WideChar, err_sz:u32,err_ptr:*mut WideChar) -> *const WideChar { // call dealloc from AHK to avoid memory leak!
  let err_cstr 	= u16cstr!("Some null lurking inside!");
  let err_utf16	= u16cstr!("Found invalid UTF16 sequences!");

  let db = db_find();
  let db_path = match db {
    Ok(file)	=> file,
    Err(_e)  	=> return ret_error(u16cstr!("✗ No database!"),err_sz,err_ptr)};
  // let mut synchronizer = Synchronizer::new(db_path.as_os_str()); // TODO: make it accept OsStr
  let mut synchronizer = Synchronizer::new(&db_path.to_string_lossy()); // Initialize the Synchronizer
  let data = match unsafe { synchronizer.read::<Win32const>() } { // Read data from shared memory
    Ok(mmf)	=> mmf,
    Err(_e)	=> return ret_error(u16cstr!("✗ Failed to read data!"),err_sz,err_ptr)};

  let pre_wc	        	= unsafe {U16CStr::from_ptr_str(pre)}; // Constructs a wide C string slice from a nul-terminated string pointer // LOCALE_
  let s_wc  	        	= unsafe {U16CStr::from_ptr_str(s  )}; // ... panics if on null
  let pre_wx	:&U16Str	= pre_wc.as_ustr(); // 16b wide string slice with undefined encoding
  let s_wx  	:&U16Str	= s_wc  .as_ustr(); // NO NULL-term
  // reject invalid UTF16 (skip check with from_ustr_unchecked if certain input is valid UTF16)
  let pre_w	:&Utf16Str = match Utf16Str::from_ustr(pre_wx){Ok(s)=>s, Err(_e)=>return ret_error(err_utf16,err_sz,err_ptr)};
  let s_w  	:&Utf16Str = match Utf16Str::from_ustr(s_wx  ){Ok(s)=>s, Err(_e)=>return ret_error(err_utf16,err_sz,err_ptr)};
  // Convert to UTF8
  let pre_s  	:String = pre_w.to_string(); // since it's valid UTF16, conversion is lossless and non-fallible
  let s_s    	:String = s_w  .to_string();
  // Find key
  let keys:[&str; 3] = [&(pre_s.clone()       + &s_s) // search the original 1st
   ,                    &(pre_s.clone() + "_" + &s_s) // then with a _
   ,                    &(pre_s               + &s_s).to_ascii_lowercase()]; // search lowercase (with all subs)
  for k in keys {
    if let Some(val) = data.hash_map_vec.get(k) { // Access fields of the struct
      if let Ok(val_w16cs) = U16CString::from_str(val)	{return val_w16cs.into_raw()
      } else                                          	{return ret_error(err_cstr,err_sz,err_ptr)}
    }
  }
  ret_error(u16cstr!("✗ Value not found!"),err_sz,err_ptr)
}

/** # SAFETY
  Must be called only with a pointer generated by another Rust function via `.into_raw`. The pointer can't be used after this call, and the FFI receiver of this pointer can't edit it*/
#[no_mangle] pub extern "system"
fn dealloc_lib_str(str_ptr:*mut i8) {unsafe{let _ = CString::from_raw(str_ptr);}}
