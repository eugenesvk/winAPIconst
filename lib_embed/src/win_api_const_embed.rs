/*! Get a Windows API constant value from an embedded database

See win_api_const.ahk for an example on how to use in AutoHotkey
*/

// 0 Return value from a key found in a PHF hashmap
include!(concat!("../../data/","/win32const_codegen.rs")); // imports static win32_const:phf::Map<&'static str,&'static str>

use widestring::{U16Str,WideChar,u16cstr,
  U16CString,U16CStr,	//   0 U16/U32-CString wide version of the standard CString type
  Utf16Str   ,       	// no0 UTF-16 encoded, growable owned string
};


use std     	::{self,slice,ptr};
use std::ffi	::{CString};

fn ret_error(err_msg:&U16CStr, err_sz:u32,err_ptr:*mut WideChar) -> *const WideChar { // create a buffer from pointer/size and fill it in
  let err_msg_bufer   	= unsafe{slice::from_raw_parts_mut::<WideChar>(err_ptr, err_sz as usize)};
  let err_msg_b:&[u16]	= err_msg.as_slice_with_nul(); // converts to a slice of the underlying elements, including the nul terminator.
  let max_buff_len    	= std::cmp::min(err_msg_b.len(),err_sz as usize);
  err_msg_bufer[..max_buff_len].copy_from_slice(&err_msg_b[..max_buff_len]);
  ptr::null()
}

#[no_mangle] pub extern "C"
fn get_win32_const(pre:&WideChar,s:&WideChar, err_sz:u32,err_ptr:*mut WideChar) -> *const WideChar { // call dealloc from AHK to avoid memory leak!
  let err_cstr 	= u16cstr!("Some null lurking inside!");
  let err_utf16	= u16cstr!("Found invalid UTF16 sequences!");

  let pre_wc	        	= unsafe {U16CStr::from_ptr_str(pre)}; // Constructs a wide C string slice from a nul-terminated string pointer // LOCALE_
  let s_wc  	        	= unsafe {U16CStr::from_ptr_str(s  )}; // ... panics if on null
  let pre_wx	:&U16Str	= pre_wc.as_ustr(); // 16b wide string slice with undefined encoding
  let s_wx  	:&U16Str	= s_wc  .as_ustr(); // NO NULL-term
  // reject invalid UTF16 (skip check with from_ustr_unchecked if certain input is valid UTF16)
  let pre_w	:&Utf16Str = match Utf16Str::from_ustr(pre_wx){Ok(s)=>s, Err(_e)=>return ret_error(err_utf16,err_sz,err_ptr)};
  let s_w  	:&Utf16Str = match Utf16Str::from_ustr(s_wx  ){Ok(s)=>s, Err(_e)=>return ret_error(err_utf16,err_sz,err_ptr)};
  // Convert to UTF8
  let pre_s  	:String = pre_w.to_string(); // since it's valid UTF16, conversion is lossless and non-fallible
  let s_s    	:String = s_w  .to_string();
  // Find key
  let keys:[&str; 3] = [&(pre_s.clone()       + &s_s) // search the original 1st
   ,                    &(pre_s.clone() + "_" + &s_s) // then with a _
   ,                    &(pre_s               + &s_s).to_ascii_lowercase()]; // search lowercase (with all subs)
  for k in keys {
    if let Some(val) = win32_const.get(k) {
      if let Ok(val_w16cs) = U16CString::from_str(val)	{return val_w16cs.into_raw()
      } else                                          	{return ret_error(err_cstr,err_sz,err_ptr)}
    }
  }
  ret_error(u16cstr!("âœ— Value not found!"),err_sz,err_ptr)
}

/** # SAFETY
  Must be called only with a pointer generated by another Rust function via `.into_raw`. The pointer can't be used after this call, and the FFI receiver of this pointer can't edit it*/
#[no_mangle] pub extern "system"
fn dealloc_lib_str(str_ptr:*mut i8) {unsafe{let _ = CString::from_raw(str_ptr);}}
